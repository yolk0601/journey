// https://juejin.im/post/5b0b7d74518825158e173a0c
网站性能指标： 白屏时间，首屏时间，整页时间，DNS时间，CPU占用率。

性能优化：网络传输性能，页面渲染性能 以及js阻塞性能。

浏览器得到用户请求后，经历了：
重定向--拉取缓存--DNS查询--建立TCP链接--发起请求--接收响应--处理HTML元素--元素加载完成。

1. 浏览器缓存。 -- 第二次访问才会有效果
浏览器在向服务器发送请求前，先查询本地是否有相同的文件，
如果有，直接拉取缓存文件。和后台部署的 Redis,Memcache类似，起到了中间缓冲的作用。

2. 资源打包压缩-- 首次打开就有良好的性能优化。
减少请求数， 奸笑请求资源体积，提升网络传输速率。

3. 图片资源优化。
真正占用大量网络传输的资源是图片。
不要在html里缩放图像， 使用雪碧图(css sprite)，使用字体图标，使用webP格式

4. 网络传输性能检测工具-- page speed
监测网络传输性能的插件——Page speed

5. 使用CDN


页面渲染性能优化

1. 浏览器渲染过程
需要减少重排 和重绘。

2. DOM渲染层与GPU硬件加速
布局是由CPU处理的，而绘制则是由GPU完成的
chrome开发者工具菜单→more tools→Layers（开启渲染层功能模块）
chrome开发者工具菜单→more tools→rendering（开启渲染性能监测工具）

那么问题来了，什么情况下会触发渲染层呢？
大家只要记住：
Video元素、WebGL、Canvas、CSS3 3D、CSS滤镜、z-index大于某个相邻节点的元素都会触发新的Layer，
其实我们最常用的方法，就是给某个元素加上下面的样式：
transform: translateZ(0);
backface-visibility: hidden;
这样就可以触发渲染层啦 

我们把容易触发重排重绘的元素单独触发渲染层，让它与那些“静态”元素隔离，
让GPU分担更多的渲染工作，我们通常把这样的措施成为硬件加速，或者是GPU加速。
大家之前肯定听过这个说法，现在完全清楚它的原理了吧。

3. 重排与重绘
重排（reflow）：渲染层内的元素布局发生修改，都会导致页面重新排列，
比如窗口的尺寸发生变化、删除或添加DOM元素，
修改了影响元素盒子大小的CSS属性（诸如：width、height、padding）。

重绘（repaint）：绘制，即渲染上色，所有对元素的视觉表现属性的修改，都会引发重绘。

重排是由CPU处理的，而重绘是由GPU处理的，CPU的处理效率远不及GPU，并且重排一定会引发重绘，而重绘不一定会引发重排。
所以在性能优化工作中，我们更应当着重减少重排的发生。

4. 优化策略
4.1 CSS属性读写分离：浏览器每次对元素样式进行读操作时，都必须进行一次重新渲染（重排 + 重绘），所以我们在使用JS对元素样式进行读写操作时，最好将两者分离开，先读后写，避免出现两者交叉使用的情况。最最最客观的解决方案，就是不用JS去操作元素样式
4.2 通过切换class 或者使用元素的 style.css text属性去批量操作元素样式。
4.3 DOM元素离线更新：当对DOM进行相关操作时，例、appendChild等都可以使用Document Fragment对象进行离线操作，带元素“组装”完成后再一次插入页面，或者使用display:none 对元素隐藏，在元素“消失”后进行相关操作。
4.4 将没用的元素设为不可见：visibility: hidden，这样可以减小重绘的压力，必要的时候再将元素显示
4.5 压缩DOM的深度，一个渲染层内不要有过深的子元素，少用DOM完成页面样式，多使用伪元素或者box-shadow取代。
4.6 图片在渲染前指定大小：因为img元素是内联元素，所以在加载图片后会改变宽高，严重的情况会导致整个页面重排，所以最好在渲染前就指定其大小，或者让其脱离文档流。
4.7 对页面中可能发生大量重排重绘的元素单独触发渲染层，使用GPU分担CPU压力。通常情况下，我们会对动画元素采取硬件加速。

JS阻塞性能

